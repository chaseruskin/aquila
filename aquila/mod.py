'''
Common primitive functionality used across target scripts.
'''

import os
from typing import List, Tuple
from enum import Enum
import argparse
import shutil
import subprocess
import json

from abc import ABC

class ScriptFile(ABC):
    """
    Wrapper to help write scripts in Python.
    """

    def __init__(self, path: str):
        """
        Create a new script destined to be written to `path`.
        """
        self._file: str = path
        self._data: str = ''
        self._indent: int = 0
        self._TAB = '    '
        self.comment('This file is automatically @generated by another program.')
        self.comment('It is not intended for manual editing.')
        self.push()
        pass

    def push(self, line='', end='\n'):
        """
        Append a new line to the current script.
        """
        if isinstance(line, str):
            self._data += (self._TAB*self._indent) + line
        elif isinstance(line, list):
            self._data += (self._TAB*self._indent)
            for c in line:
                self._data += str(c) + ' '
            pass
            # remove trailing whitespace
            if len(line) > 0:
                self._data = self._data[:-1]
        else:
            raise ValueError
        
        self._data += end
        pass

    def comment(self, msg, end='\n', token='#'):
        """
        Write a comment on a new line for the current script
        """
        self._data += (self._TAB*self._indent) + token + ' ' + str(msg)
        self._data += end

    def save(self):
        """
        Write the script contents to the file.
        """
        with open(self._file, 'w') as f:
            f.write(self._data)
        pass

    def indent(self):
        """
        Increment the indentation level for readability purposes.
        """
        self._indent += 1

    def dedent(self):
        """
        Decrement the indentation level for readability purposes.
        """
        self._indent -= 1
        if self._indent < 0:
            self._indent = 0
        pass

    def get_path(self) -> str:
        """
        Return the file system path for this script.
        """
        return self._file
    pass

class TclScript(ScriptFile):
    """
    Wrapper to help write tcl scripts in Python.
    """
    pass

class DoFile(ScriptFile):
    """
    Wrapper to help write do files in Python.
    """
    pass


class Env:
    @staticmethod
    def quote_str(s: str) -> str:
        """
        Wraps the string `s` around double quotes `\"` characters."
        """
        return '\"' + s + '\"'

    @staticmethod
    def read(key: str, default: str=None, missing_ok: bool=True) -> None:
        try:
            value = os.environ[key]
        except KeyError:
            value = None
        # do not allow empty values to trigger variable
        if value is not None and len(value) == 0:
            value = None
        if value is None:
            if missing_ok == False:
                exit("error: environment variable "+Env.quote_str(key)+" does not exist")
            else:
                value = default
        return value

    @staticmethod
    def write(key: str, value: str):
        os.environ[key] = str(value)

    @staticmethod
    def add_path(path: str) -> bool:
        if path is not None and os.path.exists(path) and len(path) > 0 and path not in os.getenv("PATH"):
            os.environ["PATH"] += os.pathsep + path
            return True
        return False
    
    @staticmethod
    def prepend(key, value: str):
        if value is not None and os.path.exists(value) and len(value) > 0 and (os.getenv(key) is None or value not in os.getenv(key)):
            if os.getenv(key) is None:
                os.environ[key] = value + os.pathsep
            else:
                os.environ[key] = value + os.pathsep + os.environ[key]

    @staticmethod
    def append(key, value: str):
        if value is not None and os.path.exists(value) and len(value) > 0 and (os.getenv(key) is None or value not in os.getenv(key)):
            if os.getenv(key) is None:
                os.environ[key] = value
            else:
                os.environ[key] += os.pathsep + value


class Entry:
    """
    An `Entry` is a single source item within a blueprint.
    """

    def __init__(self, fset: str, lib: str, path: str, deps: list=[]):
        self.fset = str(fset).upper().replace(' ', '-').replace('_', '-')
        self.lib = lib
        self.path = path
        self.deps = deps

    def is_builtin(self) -> bool:
        """
        Checks if the entry belongs to a builtin fileset (VHDL, VLOG, SYSV).
        """
        return self.fset == 'VHDL' or self.fset == 'VLOG' or self.fset == 'SYSV'
    
    def is_set(self, fset) -> bool:
        """
        Checks if the given entry belongs to this fileset `fset`.
        """
        return self.fset == str(fset).upper().replace(' ', '-').replace('_', '-')
    
    def is_aux(self, fset: str) -> bool:
        return self.fset == str(fset).upper().replace(' ', '-').replace('_', '-')

    def is_vhdl(self) -> bool:
        """
        Checks if the given entry belongs to the builtin VHDL filset.
        """
        return self.fset == 'VHDL'
    
    def is_vlog(self) -> bool:
        """
        Checks if the given entry belongs to the builtin VLOG filset.
        """
        return self.fset == 'VLOG'
    
    def is_sysv(self) -> bool:
        """
        Checks if the given entry belongs to the builtin SYSV filset.
        """
        return self.fset == 'SYSV'
    
    def get_deps(self) -> list:
        """
        Returns the list of file dependencies for the given entry.
        """
        return self.deps
    
    pass


class Blueprint:
    """
    A data structure that contains the topologically sorted list of all source entries.
    """

    def __init__(self):
        self._file = Env.read("ORBIT_BLUEPRINT", missing_ok=False)
        self._plan = Env.read("ORBIT_BLUEPRINT_PLAN", missing_ok=False)

        self._entries = []
        # extract the list of entries from the file according to its plan
        with open(self._file, 'r') as bp:
            if self.get_plan() == 'tsv':
                for line in bp.readlines():
                    fset, lib, path = line.strip().split('\t')
                    self._entries += [Entry(fset, lib, path)]
            elif self.get_plan() == 'json':
                data = json.load(bp)
                for d in data:
                    self._entries += [Entry(d['fileset'], d['library'], d['filepath'], d['dependencies'])]
        pass
    
    def get_entries(self) -> List[Entry]:
        """
        Returns the topologically sorted list of entries from the current
        blueprint.
        """
        return self._entries
    
    def get_plan(self) -> str:
        """
        Returns which plan was used for the current blueprint.
        """
        return self._plan

    def get_file(self) -> str:
        """
        Return the name of the file used to load the current list of entries.
        """
        return self._file
    pass


class Generic:
    def __init__(self, key: str, val: str):
        self.key = key
        self.val = val
        pass
    pass

    @classmethod
    def from_str(self, s: str):
        # split on equal sign
        words = s.split('=', 1)
        if len(words) != 2:
            return None
        return Generic(words[0], words[1])
    
    @classmethod
    def from_arg(self, s: str):
        result = Generic.from_str(s)
        if result is None:
            msg = "generic "+Env.quote_str(s)+" is missing <value>"
            raise argparse.ArgumentTypeError(msg)
        return result

    def to_str(self) -> str:
        return self.key+'='+self.val
    
    def __str__(self):
        return self.key+'='+self.val
    
    pass


class Status(Enum):
    OKAY = 0
    FAIL = 101
    pass

    @staticmethod
    def from_int(code: int):
        if code == 0:
            return Status.OKAY
        else:
            return Status.FAIL

    def unwrap(self):
        # print an error message
        if self == Status.FAIL:
            exit(Status.FAIL.value)
        pass

    def is_ok(self) -> bool:
        return self == Status.OKAY

    def is_err(self) -> bool:
        return self == Status.FAIL
    
    def __int__(self):
        return int(self.value)
    pass


class Command:
    def __init__(self, command: str):
        self._command = shutil.which(command)
        if self._command == None:
            self._command = command
        self._args = []

    def args(self, args: List[str]):
        if args is not None and len(args) > 0:
            self._args += args
        return self
    
    def arg(self, arg: str):
        # skip strings that are empty
        if arg is not None and str(arg) != '':
            self._args += [str(arg)]
        return self
    
    def spawn(self, verbose: bool=False) -> Status:
        job = [self._command] + self._args
        if verbose == True:
            command_line = self._command
            for c in self._args:
                command_line += ' ' + Env.quote_str(c)
            print('info:', command_line)
        try:
            child = subprocess.Popen(job)
        except FileNotFoundError:
            print('error: command not found: \"'+self._command+'\"')
            return Status.FAIL
        status = child.wait()
        return Status.from_int(status)
    
    def stream(self, path: str, mode: str='w') -> Status:
        '''
        Writes the stdout and stderr to the terminal while also recording it to a file.
        '''
        import re
        def execute(cmd):
            popen = subprocess.Popen(cmd, stdout=subprocess.PIPE, stderr=subprocess.STDOUT, universal_newlines=True)
            for stdout_line in iter(popen.stdout.readline, ""):
                yield stdout_line
            popen.stdout.close()
            return_code = popen.wait()
            if return_code:
                raise subprocess.CalledProcessError(return_code, cmd)
        
        job = [self._command] + self._args
        ansi_escape = re.compile(r'\x1B(?:[@-Z\\-_]|\[[0-?]*[ -/]*[@-~])')
        fd = open(path, mode)
        try:
            for line in execute(job):
                print(line, end='')
                data = ansi_escape.sub('', line)
                fd.write(data)
        except subprocess.CalledProcessError:
            fd.close()
            return Status.FAIL
        fd.close()
        return Status.OKAY

    def output(self, verbose: bool=False) -> Tuple[str, Status]:
        job = [self._command] + self._args
        # display the command being executed
        if verbose == True:
            command_line = self._command
            for c in self._args:
                command_line += ' ' + Env.quote_str(c)
            print('info:', command_line)
        # execute the command and capture channels for stdout and stderr
        try:
            pipe = subprocess.Popen(job, stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
        except FileNotFoundError:
            print('error: command not found: \"'+self._command+'\"')
            return ('', Status.FAIL)
        out, err = pipe.communicate()
        if err is not None:
            return (err.decode('utf-8'), Status.FAIL)
        if out is not None:
            return (out.decode('utf-8'), Status.OKAY)
        return ('', Status.OKAY)
    pass
